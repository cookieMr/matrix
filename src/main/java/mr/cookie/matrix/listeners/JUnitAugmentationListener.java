package mr.cookie.matrix.listeners;

import mr.cookie.matrix.random.Random;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.junit.platform.engine.TestExecutionResult;
import org.junit.platform.launcher.TestExecutionListener;
import org.junit.platform.launcher.TestIdentifier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

/**
 * An implementation of JUnit's {@link TestExecutionListener} which does two things:
 * <ol>
 *     <li>Resets {@link Random} seed before each JUnit tests to the same value.
 *     The seed value is either specified by input parameter {@code -Dseed=long_value}
 *     or is generated from {@link Random#nextLong()}.<br/>
 *     <b>NOTE:</b> Each {@code @RepeatedTest} will have the same random see, thus it will run
 *     with the same data, which defeats the purpose of running such repeated tests while
 *     this listener is registered.</li>
 *     <li>Measures time elapsed for each run test and prints it after test finishes.</li>
 * </ol>
 * This listener needs to be registered in {@code META-INF/services/org.junit.platform.launcher.TestExecutionListener}
 * file.
 */
public class JUnitAugmentationListener implements TestExecutionListener {

    private static final Logger LOG = LoggerFactory.getLogger(JUnitAugmentationListener.class);

    private static final ConcurrentHashMap<TestIdentifier, Long> executionTimeMap =
            new ConcurrentHashMap<>();

    /**
     * The seed for pseudorandom generator. It's either taken from an application input parameter
     * {@code -Dseed=long_value} or generated by {@link Random#nextLong()}.
     */
    private static final long SEED = Optional.ofNullable(System.getProperty("seed", null))
            .map(Long::valueOf)
            .orElse(Random.nextLong());

    /**
     * First thing this method does is reset the random seed in {@link Random} before each JUnit test.
     * Each test is expected to have a the same seed, so the same (repeated) test will get
     * the same random data.
     * <p/>
     * Second thing this method does is set a start time into a map, where a key is a {@link TestIdentifier}
     * and the value is current system time in nanoseconds.
     *
     * @param testIdentifier a test identifier
     */
    @Override
    public void executionStarted(@NotNull TestIdentifier testIdentifier) {
        LOG.debug("Test [{}] will be run with a seed [{}].", testIdentifier.getDisplayName(), SEED);
        Random.setSeed(SEED);

        long start = System.nanoTime();
        executionTimeMap.put(testIdentifier, start);
    }

    /**
     * Prints time elapsed for a test execution.
     *
     * @param testIdentifier      a test identifier
     * @param testExecutionResult a test execution result
     */
    @Override
    public void executionFinished(
            @NotNull TestIdentifier testIdentifier,
            @Nullable TestExecutionResult testExecutionResult) {
        long end = System.nanoTime();
        Long start = executionTimeMap.remove(testIdentifier);

        if (start == null) {
            LOG.error("Test [{}] does not have a start time.", testIdentifier.getDisplayName());
            return;
        }

        if (LOG.isInfoEnabled()) {
            float elapsedTime = (float) (end - start) / 1000;
            LOG.info("Test [{}] took [{}] milli seconds.", testIdentifier.getDisplayName(), elapsedTime);
        }
    }

}
